# OOP Code Analyzer

## Description

**OOP Code Analyzer** is a lightweight Python tool that detects whether a given piece of code follows **Object-Oriented Programming (OOP)** principles.

It uses a custom **preprocessor** and an **abstract syntax tree (AST)** to evaluate the structural components of OOP, such as:

- Classes  
- Methods  
- Constructors (`__init__`)  
- Attributes  
- Instance usage

---

## Getting Started

### Prerequisites

Make sure you have the following installed:

- Python 3.7 or higher  
- Git  

### üõ†Ô∏è Installation & Running

1. **Clone the repository**

```bash
git clone https://github.com/PaolaFelix/OOP-Python-Compiler.git
cd OOP-Python-Compiler
```

2. **Install required dependency: [PLY](https://pypi.org/project/ply/)**

```bash
pip install ply
```

3. **Run the analyzer**

```bash
python main.py
```

> **Note:**  
> By default, the tool analyzes all `.py` files in the `tests` directory.  
> Sample Python test files are already included.  
> You can add your own code by placing `.py` files inside the `tests` folder ‚Äî no extra configuration needed.

---

## Project Structure

Okay, let's complete your README.md for the OOP Code Analyzer! I'll add the project structure section, detail what each file does, and provide a more in-depth justification for using a preprocessor and AST.

Here's the complete README.md content:

OOP Code Analyzer
Description
OOP Code Analyzer is a lightweight Python tool that detects whether a given piece of code follows Object-Oriented Programming (OOP) principles.

It uses a custom preprocessor and an abstract syntax tree (AST) to evaluate the structural components of OOP, such as:

Classes
Methods
Constructors (__init__)
Attributes
Instance usage
Getting Started
Prerequisites
Make sure you have the following installed:

Python 3.7 or higher
Git
üõ†Ô∏è Installation & Running
Clone the repository

Bash

git clone https://github.com/PaolaFelix/OOP-Python-Compiler.git
cd OOP-Python-Compiler
Install required dependency: PLY

Bash

pip install ply
Run the analyzer

Bash

python main.py <directory_path>
Example:

Bash

python main.py tests
Note:
By default, the tool expects a directory path as an argument. The tests directory is included for sample Python test files. You can add your own code by placing .py files inside any folder and specifying that folder's path when running the script.

Core Components Explained

1. preprocessor.py
This module is responsible for the initial cleaning and normalization of the source code. Its primary role is to prepare the code for the subsequent lexical analysis by:

Removing Comments: Eliminates single-line (#) and multi-line ("""Docstrings""" or '''Docstrings''') comments, as they are not relevant to the code's structure for analysis.
Handling Empty Lines: Strips out blank lines to streamline the input for the lexer.
Why a Preprocessor?
A preprocessor simplifies the job of the lexer and parser. By removing non-essential elements like comments and empty lines upfront, it reduces the complexity of the grammar rules needed later. It ensures that the subsequent stages only deal with meaningful code constructs, making the entire analysis process more efficient and less prone to errors caused by extraneous characters.

2. lexer.py
The lexer (or tokenizer) is the first stage of linguistic analysis. This module takes the preprocessed code as a stream of characters and breaks it down into a sequence of tokens. Each token represents a fundamental building block of the language, such as keywords (class, def), identifiers (my_variable), operators (=, +), and punctuation (:, (). It also handles Python's unique indentation-based syntax by emitting INDENT and DEDENT tokens.

3. parser.py
The parser takes the stream of tokens generated by the lexer and constructs an Abstract Syntax Tree (AST). An AST is a tree representation of the abstract syntactic structure of source code, where each node in the tree denotes a construct occurring in the source code.

Why an Abstract Syntax Tree (AST)?
The AST is crucial because it provides a structured and hierarchical representation of your code's logic, independent of its specific syntax (like parentheses or semicolons, which Python doesn't have in the same way as other languages). For an OOP analyzer, the AST allows us to:

Identify Structure: Easily find class_def nodes, method_def nodes, and constructor_call patterns.
Analyze Relationships: Understand how methods belong to classes, how attributes are accessed within objects (obj.attr or self.attr), and how instances are created.
Semantic Analysis: Perform checks beyond just syntax, for example, verifying if __init__ methods are correctly defined within classes or if self is used as the first parameter in methods. Without an AST, analyzing OOP principles would involve complex string manipulation or less robust pattern matching on the raw code, which is highly error-prone and less scalable.
4. oop_analyzer.py
This is the core intelligence of the tool. The OOPAnalyzer class traverses the AST generated by the parser. It implements logic to:

Detect OOP Features: Identify the presence of classes, methods, constructors, instance creations, and attribute accesses by inspecting the AST nodes.
Accumulate Metrics: Count defined classes, methods, and created instances.
Generate Details: Collect specific observations about the OOP patterns found (e.g., "Class defined: MyClass", "Constructor found: __init__").
Classify Code: Based on a scoring system and predefined criteria, it classifies the input code as "C√ìDIGO OOP," "POSSIBLE OOP," "BASIC OOP ELEMENTS," or "NOT OOP."
5. main.py
The entry point of the application. It orchestrates the entire analysis workflow:

Takes the target directory path as a command-line argument.
Discovers all .py files within the specified directory.
For each file, it calls the preprocessor, then the lexer and parser to build the AST.
Finally, it passes the AST to the OOPAnalyzer for classification and prints the detailed and summarized results.

---

## Output

### Example Summary

After execution, the tool prints a detailed report for each file and a final summary like:

```
========================================
FINAL SUMMARY
========================================
test1.py: REJECTED
test2.py: REJECTED
...
test10.py: REJECTED
```

### Meaning of Results

- **`REJECTED`**: The file does **not** implement enough OOP features to be classified as object-oriented code.
- Other outputs may include labels like `"C√ìDIGO OOP"` or `"POSIBLEMENTE OOP"` for files that contain clear or partial OOP structures.
